---
title: "React Hooks 全面介绍"
date: "2023-07-24"
description: "深入了解 React Hooks 的概念、用途及使用方式，包括 useState、useEffect 等核心钩子，以及自定义 Hook 的实践。"
tags: ["React", "Hooks", "前端开发", "JavaScript"]
category: "React"
---

React Hooks 是 React 16.8 引入的一项强大功能，旨在让函数组件也能拥有类组件的状态管理和生命周期方法功能。通过 Hooks，开发者可以以更简洁和直观的方式构建组件逻辑，同时避免类组件复杂的逻辑和代码冗余。

## 什么是 React Hooks

Hooks 是一类特殊的函数，它允许你在函数组件中“钩入” React 的状态和生命周期功能。通过使用 Hooks，开发者可以无需编写类组件即可完成以下功能：

- 状态管理（例如 `useState`）
- 副作用处理（例如 `useEffect`）
- 上下文访问（例如 `useContext`）
- 引用操作（例如 `useRef`）

## 核心 Hook

### 1. useState
`useState` 是最常用的 Hook，用于在函数组件中声明状态变量。

**语法：**
```javascript
const [state, setState] = useState(initialState);
```

**例子：**
```javascript
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>当前计数: {count}</p>
      <button onClick={() => setCount(count + 1)}>增加</button>
    </div>
  );
}

export default Counter;
```

在上面的例子中，`count` 是一个状态变量，初始值为 `0`。`setCount` 是用来更新状态的函数。

### 2. useEffect
`useEffect` 用于处理副作用，例如数据获取、订阅、手动 DOM 操作等。

**语法：**
```javascript
useEffect(() => {
  // 副作用逻辑
  return () => {
    // 清理逻辑
  };
}, [dependencies]);
```

**例子：**
```javascript
import React, { useState, useEffect } from "react";

function Timer() {
  const [time, setTime] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setTime((prevTime) => prevTime + 1);
    }, 1000);

    return () => clearInterval(interval); // 清理定时器
  }, []);

  return <p>计时: {time} 秒</p>;
}

export default Timer;
```

在这个例子中，`useEffect` 设置了一个定时器，每秒更新一次状态，同时通过返回一个清理函数来避免内存泄漏。

### 3. useContext
`useContext` 用于访问上下文对象。

**例子：**
```javascript
import React, { createContext, useContext } from "react";

const ThemeContext = createContext("light");

function ThemeButton() {
  const theme = useContext(ThemeContext);
  return <button className={theme}>当前主题: {theme}</button>;
}

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemeButton />
    </ThemeContext.Provider>
  );
}

export default App;
```

### 4. useRef
`useRef` 用于引用 DOM 元素或存储可变变量。

**例子：**
```javascript
import React, { useRef } from "react";

function FocusInput() {
  const inputRef = useRef(null);

  const handleFocus = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={handleFocus}>聚焦输入框</button>
    </div>
  );
}

export default FocusInput;
```

### 5. useReducer
`useReducer` 是 `useState` 的替代方案，适合处理更复杂的状态逻辑。

**例子：**
```javascript
import React, { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <p>计数: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>增加</button>
      <button onClick={() => dispatch({ type: "decrement" })}>减少</button>
    </div>
  );
}

export default Counter;
```

## 自定义 Hook

开发者可以创建自定义 Hook，将逻辑封装成可复用的函数。

**例子：**
```javascript
import { useState, useEffect } from "react";

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch(url)
      .then((response) => response.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      });
  }, [url]);

  return { data, loading };
}

function App() {
  const { data, loading } = useFetch("https://api.example.com/data");

  if (loading) return <p>加载中...</p>;

  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}

export default App;
```

## 总结

React Hooks 大大简化了函数组件的开发流程，使组件逻辑更加清晰和模块化。无论是管理状态、处理副作用还是封装自定义逻辑，Hooks 都提供了灵活高效的解决方案。通过合理使用 Hooks，可以让代码更加优雅和易于维护。
