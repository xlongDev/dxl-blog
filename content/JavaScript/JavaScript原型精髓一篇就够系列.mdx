---
title: "JavaScript 原型精髓 一篇就够系列"
date: "2023-02-05"
description: "一篇深入剖析 JavaScript 原型机制的全面指南，带你从原理到实践，解锁前端开发的核心技能。"
keywords: "JavaScript, 原型, 原型链, 继承, 前端开发, 对象, ES6, 最佳实践"
author: "晓龙"
image: "/images/hero/js-prototype.jpg"
tags: ["JavaScript", "前端开发", "编程基础"]
category: "JavaScript"
---

Hey，前端小伙伴们 👋！今天咱们要聊一个 JavaScript 里既神秘又让人抓狂的话题——**原型**（Prototype）。如果你曾经被 `prototype`、`__proto__` 和原型链搞得晕头转向，或者在面试中被问到“对象和函数的原型关系是什么”时一脸懵逼，那这篇文章就是为你量身打造的。咱不整那些枯燥的教科书式讲解，而是用接地气的语言、鲜活的例子和一点小幽默，带你从原理到实践彻底搞懂原型。目标只有一个：**读完这篇，你就是原型大师** 💪！

这篇文章会从“原型是什么”开始讲起，逐步深入到原型链、继承的实现，再到 ES6 的优化和最佳实践。每个部分都会有代码示例、类比和实用 tips，保证你不仅能看懂，还能用得上。准备好了吗？Let’s dive in!

## 一、原型是个啥？从“家谱”说起

在 JavaScript 里，**原型**本质上是一个对象，用来实现属性和方法的共享。每个对象都有一个隐藏的“家谱身份证”——`__proto__`，它指向另一个对象，也就是它的原型。而这个原型对象也有自己的 `__proto__`，一层一层往上追溯，最终指向 `null`，这就是所谓的**原型链**。

用生活化的比喻来说，原型就像你家里的“祖传秘方”：你爸有一本秘方书（原型），你没写自己的秘方时，默认用你爸的；你爸的秘方又继承自你爷爷（上一层原型），直到祖宗那代秘方用完为止（`null`）。这不就是家族传承嘛？😂

### 动手试试：原型的基本关系

```javascript
const person = {
  sayHello() {
    console.log("Hello, I’m a person!");
  },
};

const xiaolong = Object.create(person);
xiaolong.name = "晓龙";

console.log(xiaolong.name); // "晓龙"
xiaolong.sayHello(); // "Hello, I’m a person!"
console.log(xiaolong.__proto__ === person); // true
```

在这段代码里，`Object.create(person)` 创建了一个新对象 `xiaolong`，它的原型指向 `person`。当你调用 `xiaolong.sayHello()` 时，JavaScript 发现 `xiaolong` 自己没这个方法，就顺着 `__proto__` 找到 `person`，拿到了 `sayHello`。这不就是“子承父业”吗？

**Tips**: `__proto__` 是老派写法，虽然还能用，但不推荐。现代 JS 更倾向于用 `Object.getPrototypeOf()` 来获取原型，显得更专业一点。

## 二、原型链：从“找爹”到“找祖宗”

原型链是 JavaScript 查找属性和方法的机制。当你访问一个对象的属性时，JS 会先在对象本身找，找不到就去它的原型（`__proto__`）里找，再找不到就继续往上，直到 `null`。这就像你在家找东西，先翻自己抽屉，没找到就问爸妈，爸妈没有就去翻爷爷的箱子。

### 示例：原型链的查找过程

```javascript
const grandpa = {
  familyTreasure: "金戒指",
};

const dad = {
  __proto__: grandpa,
  money: 100,
};

const me = {
  __proto__: dad,
  name: "晓龙",
};

console.log(me.name); // "晓龙"
console.log(me.money); // 100
console.log(me.familyTreasure); // "金戒指"
console.log(me.toString); // [Function: toString]（来自 Object.prototype）
```

在这段代码里，`me.familyTreasure` 的查找过程是：`me` → `dad` → `grandpa`，最后在 `grandpa` 找到。而 `me.toString` 甚至追溯到了 `Object.prototype`，因为所有对象最终都继承自它。

**思维链**：
1. 访问 `me.familyTreasure`。
2. `me` 没有，直接看 `me.__proto__`（也就是 `dad`）。
3. `dad` 没有，继续看 `dad.__proto__`（也就是 `grandpa`）。
4. `grandpa` 有，返回 `"金戒指"`。
5. 如果一路没找到，最终到 `Object.prototype.__proto__`（也就是 `null`），返回 `undefined`。

**Tips**: 原型链太长会影响性能，尽量保持扁平化。别整出个“十代单传”的原型链，找属性找得 CPU 都冒烟了 🔥。

## 三、构造函数与 prototype 的“双人舞”

说到原型，就离不开构造函数和 `prototype` 属性。在 JS 里，每个函数都有一个 `prototype` 属性，默认是一个对象，里面有个 `constructor` 指向函数本身。而通过 `new` 创建的对象，其 `__proto__` 会指向构造函数的 `prototype`。

听起来有点绕？别急，咱用个例子搞明白。

### 示例：构造函数与原型的关系 “

```javascript
function Cat(name) {
  this.name = name;
}

Cat.prototype.meow = function () {
  console.log(`${this.name} says: Meow!`);
};

const kitty = new Cat("小黑");
kitty.meow(); // "小黑 says: Meow!"
console.log(kitty.__proto__ === Cat.prototype); // true
```

这里，`Cat.prototype` 是所有 `Cat` 实例的原型。`kitty` 通过 `new Cat()` 创建，它的 `__proto__` 指向 `Cat.prototype`，所以能调用 `meow`。

**类比**：`prototype` 就像一个“共享技能包”，每个通过 `new` 创建的实例都能免费领取一份技能。而 `__proto__` 是实例的“技能索引”，告诉你去哪找这些技能。

**Tips**: 修改 `prototype` 时要小心。如果你直接赋值（`Cat.prototype = {}`），会切断原有的 `constructor` 关系，导致 `kitty.constructor` 变成 `Object`。正确做法是用 `Object.defineProperty` 修补：

```javascript
Cat.prototype = {
  meow() {
    console.log(`${this.name} says: Meow!`);
  },
};
Object.defineProperty(Cat.prototype, "constructor", {
  value: Cat,
  writable: true,
});
```

## 四、继承的几种姿势：从“借鸡生蛋”到 ES6

JavaScript 的继承主要靠原型实现，早期有几种经典方法，咱们逐一拆解。

### 1. 原型链继承

```javascript
function Animal() {
  this.type = "动物";
}

Animal.prototype.eat = function () {
  console.log("吃东西");
};

function Dog() {
  this.breed = "哈士奇";
}

Dog.prototype = new Animal();
const husky = new Dog();

husky.eat(); // "吃东西"
console.log(husky.type); // "动物"
```

**优缺点**：简单，但所有实例共享同一个原型对象，改一个全完蛋。就像家族共用一个保险箱，谁乱花钱大家都得跟着破产 😂。

### 2. 借用构造函数（call/apply）

```javascript
function Animal(type) {
  this.type = type;
}

function Dog(breed) {
  Animal.call(this, "狗狗");
  this.breed = breed;
}

const husky = new Dog("哈士奇");
console.log(husky.type); // "狗狗"
console.log(husky.breed); // "哈士奇"
```

**优缺点**：能传参，避免共享问题，但没法继承原型上的方法。相当于只继承了“家产”，没拿到“祖传秘方”。

### 3. 组合继承（最常用）

```javascript
function Animal(type) {
  this.type = type;
}

Animal.prototype.eat = function () {
  console.log("吃东西");
};

function Dog(breed) {
  Animal.call(this, "狗狗");
  this.breed = breed;
}

Dog.prototype = new Animal();
Dog.prototype.constructor = Dog;

const husky = new Dog("哈士奇");
husky.eat(); // "吃东西"
console.log(husky.type); // "狗狗"
```

**优缺点**：结合了前两者的优点，但 `Animal` 被调用两次（`call` 和 `new`），有点浪费性能。

### 4. ES6 的 class（语法糖）

```javascript
class Animal {
  constructor(type) {
    this.type = type;
  }
  eat() {
    console.log("吃东西");
  }
}

class Dog extends Animal {
  constructor(breed) {
    super("狗狗");
    this.breed = breed;
  }
}

const husky = new Dog("哈士奇");
husky.eat(); // "吃东西"
console.log(husky.type); // "狗狗"
```

**真相**：`class` 只是原型继承的语法糖，底层还是靠 `prototype` 和 `__proto__`。用 `Dog.prototype.__proto__ === Animal.prototype` 检查一下就知道了。

**Tips**: 用 ES6 的 `class` 写继承代码更清晰，但调试时别忘了看底层的原型链，别被表面的“面向对象”骗了 😂。

## 五、原型的高级玩法与优化

### 1. 动态修改原型

你可以在运行时给原型加方法，所有实例都能用：

```javascript
function Person(name) {
  this.name = name;
}

const xiaolong = new Person("晓龙");

Person.prototype.sayHi = function () {
  console.log(`Hi, I’m ${this.name}`);
};

xiaolong.sayHi(); // "Hi, I’m 晓龙"
```

**Tips**: 动态修改原型很强大，但别滥用。频繁改动会导致代码难以追踪，像是在“热车引擎上换零件”。

### 2. 性能优化：缓存原型方法

如果原型方法会被频繁调用，可以缓存：

```javascript
function Calculator() {}
Calculator.prototype.add = function (a, b) {
  return a + b;
};

const calc = new Calculator();
const add = calc.add.bind(calc); // 缓存方法
console.log(add(1, 2)); // 3
```

**Tips**: 缓存方法能减少原型链查找，尤其在性能敏感的场景（比如游戏循环）很实用。

## 六、最佳实践：让原型为我所用

1. **扁平化原型链**  
   原型链太深就像“快递层层转包”，效率低还容易出错。尽量控制在 2-3 层。

2. **优先用 ES6 class**  
   代码可读性强，维护方便，面试官看了也开心 😎。

3. **避免直接操作 __proto__**  
   用 `Object.setPrototypeOf()` 或 `Object.create()` 替代，性能更好且更规范。

4. **检查属性归属**  
   用 `hasOwnProperty` 判断属性是自己的还是原型上的，别稀里糊涂拿了“祖产”还以为是自己挣的。

```javascript
const obj = { __proto__: { inherited: "祖产" } };
console.log(obj.hasOwnProperty("inherited")); // false
```

5. **文档化你的原型设计**  
   团队项目中，写清楚哪些方法挂在原型上，免得同事一脸问号：这方法哪来的？

## 七、结尾：原型是你的超能力

原型是 JavaScript 的核心之一，理解它就像解锁了前端开发的“内功心法”。从原型链的查找，到继承的实现，再到性能优化，每一步都在让你更接近 JS 的本质。希望这篇博客能帮你把原型从“雾里看花”变成“了然于胸”。下次面试被问到原型问题，你可以自信地说：“这还不简单？我可是原型大师！” 😎

有什么疑问或者想聊聊原型的高级用法？欢迎留言，咱们一起探讨！ 🚀

---