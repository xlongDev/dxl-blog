---
title: "JavaScript 集合引用类型详解"
date: "2022-01-11"
description: "从 Set 到 Map，从 WeakSet 到 WeakMap，深入剖析 JavaScript 中的集合引用类型，带你理解原理、踩坑经验和最佳实践。"
keywords: "JavaScript, Set, Map, WeakSet, WeakMap, 集合引用类型, 对象引用, 垃圾回收, 编程最佳实践"
author: "晓龙"
image: "/images/hero/js-collections.jpg"
tags: ["JavaScript", "前端开发", "编程基础"]
category: "JavaScript"
---

嘿，朋友！今天我们来聊聊 JavaScript 中那些有点“高冷”但超级实用的集合引用类型——`Set`、`Map`、`WeakSet` 和 `WeakMap`。如果你觉得 JavaScript 只有数组和对象那点老套路，那这篇文章可能会让你眼前一亮 ✨。这些家伙不仅能帮你优雅地解决问题，还能在某些场景下大幅提升代码性能，甚至拯救你的内存。准备好了吗？让我们一起跳进这个集合的世界吧！

## 什么是集合引用类型？

在 JavaScript 中，引用类型本质上是那些“住在堆内存里”的家伙，比如对象、数组。而集合引用类型（Collection Reference Types）是 ES6（以及后续版本）引入的几种专门用来处理数据的结构：`Set`、`Map`、`WeakSet` 和 `WeakMap`。它们不像数组那样一根筋地按顺序排队，也不像普通对象那样只认字符串键，而是各有各的脾气和绝活。

类比一下：如果数组是个老实巴交的收纳盒，对象是个贴满标签的档案柜，那这些集合引用类型就像是 Swiss Army Knife（瑞士军刀）——功能多、用途广，但得知道怎么用，不然可能会割到手 😂。

接下来，我会逐一拆解这四位“选手”，从原理到用法，再到一些你可能没注意过的坑，最后还有几招最佳实践。走起！

---

## 1. Set：去重小能手

### 1.1 基本概念

`Set` 是个“只存独特值”的集合。简单来说，它就像一个自带去重功能的数组，但比数组更纯粹——它压根不关心顺序，也不给你索引。

```javascript
const mySet = new Set();
mySet.add(1);
mySet.add(2);
mySet.add(1); // 重复值？抱歉，Set 不吃这一套
console.log(mySet); // Set { 1, 2 }
```

### 1.2 底层原理

`Set` 的去重魔法是怎么实现的呢？它内部用了一种类似哈希表的东西，通过值的“同一性”来判断是否重复。具体来说，`Set` 使用的是 **SameValueZero 算法**，这玩意儿比 `===` 还严格，但对 `NaN` 有点特殊——它认为 `NaN` 和 `NaN` 是同一个东西（不像 `===` 那样返回 `false`）。

```javascript
const set = new Set();
set.add(NaN);
set.add(NaN);
console.log(set.size); // 1，NaN 被认为是同一个值
```

### 1.3 常用方法

- `add(value)`：添加一个值。
- `has(value)`：检查是否存在。
- `delete(value)`：删除某个值。
- `clear()`：清空整个 Set。
- `size`：获取元素个数（注意，不是 length，是 size！）。

```javascript
const fruits = new Set(["apple", "banana"]);
fruits.add("orange");
console.log(fruits.has("apple")); // true
fruits.delete("banana");
console.log(fruits); // Set { 'apple', 'orange' }
```

### 1.4 实战举例

假设你在写一个点赞系统，要统计哪些用户点了赞。数组可以用，但如果用户重复点赞，处理起来就麻烦了。`Set` 完美解决：

```javascript
const likedUsers = new Set();
likedUsers.add("Alice");
likedUsers.add("Bob");
likedUsers.add("Alice"); // Alice 又点了一次？无所谓，Set 自动去重
console.log(likedUsers.size); // 2
```

### 1.5 小心这些坑

- **对象引用**：`Set` 对对象是按引用比较的，不是值比较。
  
```javascript
const set = new Set();
const obj1 = { id: 1 };
const obj2 = { id: 1 };
set.add(obj1);
set.add(obj2);
console.log(set.size); // 2，因为 obj1 和 obj2 是不同的引用
```

- **不可直接遍历键值**：想用 `for...of` 遍历？可以，但它只给你值，没索引。

```javascript
for (const value of new Set([1, 2, 3])) {
  console.log(value); // 1, 2, 3
}
```

### 1.6 最佳实践

- **去重数组**：最常见的用法，优雅又高效。
  
```javascript
const arr = [1, 2, 2, 3, 3, 4];
const uniqueArr = [...new Set(arr)]; // [1, 2, 3, 4]
```

- **性能敏感场景**：查找和删除操作的时间复杂度是 O(1)，比数组的 `indexOf`（O(n)）快得多。

---

## 2. Map：键值对的自由派

### 2.1 基本概念

`Map` 是一个键值对集合，和普通对象有点像，但它最大的特点是：**键可以是任意类型**，不仅仅是字符串或 Symbol。

```javascript
const myMap = new Map();
myMap.set("name", "晓龙");
myMap.set(42, "The Answer");
const objKey = { id: 1 };
myMap.set(objKey, "Object Key!");
console.log(myMap.get(objKey)); // "Object Key!"
```

### 2.2 底层原理

`Map` 也是基于哈希表的实现，但它对键的处理更灵活。普通对象的键会被强制转为字符串（比如 `[object Object]`），而 `Map` 保留了键的原始类型，通过引用来区分。

```javascript
const map = new Map();
const key1 = {};
const key2 = {};
map.set(key1, "one");
map.set(key2, "two");
console.log(map.get(key1)); // "one"，键是按引用区分的
```

### 2.3 常用方法

- `set(key, value)`：设置键值对。
- `get(key)`：获取值。
- `has(key)`：检查键是否存在。
- `delete(key)`：删除某个键值对。
- `clear()`：清空。
- `size`：键值对数量。

### 2.4 实战举例

假设你在做一个多语言翻译系统，键是语言代码，值是翻译文本。对象可以用，但如果键变成动态的复杂对象呢？`Map` 更合适：

```javascript
const translations = new Map();
translations.set(["en", "greeting"], "Hello");
translations.set(["zh", "greeting"], "你好");
console.log(translations.get(["en", "greeting"])); // undefined，因为数组是引用类型
```

Oops！这里踩坑了——数组是引用类型，每次 `[]` 都是新引用。正确的做法是：

```javascript
const enGreeting = ["en", "greeting"];
translations.set(enGreeting, "Hello");
console.log(translations.get(enGreeting)); // "Hello"
```

### 2.5 Map vs Object

- **键的类型**：对象只能用字符串/Symbol，`Map` 无限制。
- **大小**：对象得用 `Object.keys().length`，`Map` 有 `size`。
- **性能**：`Map` 在频繁增删键值对时更有优势。

### 2.6 最佳实践

- **复杂键场景**：当键是对象或函数时，用 `Map`。
- **JSON 序列化**：`Map` 不能直接 `JSON.stringify`，需要手动转换。

```javascript
const map = new Map([["a", 1], ["b", 2]]);
const obj = Object.fromEntries(map);
console.log(JSON.stringify(obj)); // {"a":1,"b":2}
```

---

## 3. WeakSet & WeakMap：内存管理的隐秘高手

### 3.1 WeakSet：弱引用的集合

`WeakSet` 和 `Set` 长得像，但它只存对象，而且是**弱引用**——不会阻止垃圾回收。

```javascript
const weakSet = new WeakSet();
let obj = { id: 1 };
weakSet.add(obj);
console.log(weakSet.has(obj)); // true
obj = null; // obj 被置为 null，可能被垃圾回收
// weakSet.has(obj) 无法预测，因为 obj 可能已经没了
```

### 3.2 WeakMap：弱引用的键值对

`WeakMap` 同理，键必须是对象，值随意，且键是弱引用。

```javascript
const weakMap = new WeakMap();
let key = { id: 1 };
weakMap.set(key, "晓龙");
console.log(weakMap.get(key)); // "晓龙"
key = null; // key 可能被回收，weakMap 也会清空对应条目
```

### 3.3 底层原理

“弱引用”是关键。普通 `Set` 和 `Map` 会强引用它们的元素，导致即使外部引用没了，内存也不会释放。而 `WeakSet` 和 `WeakMap` 不会挡着垃圾回收的路，适合临时存储或缓存。

### 3.4 实战举例

假设你在写一个 DOM 元素的管理工具，想记录每个元素的元数据，但又不想妨碍 DOM 被移除时的内存回收：

```javascript
const metaData = new WeakMap();
const button = document.querySelector("#myButton");
metaData.set(button, { clicked: 0 });
button.addEventListener("click", () => {
  const data = metaData.get(button);
  data.clicked++;
});
```

当 `button` 被移除，`WeakMap` 不会阻止它被回收，内存安全得很！

### 3.5 限制与注意

- **不可枚举**：没有 `forEach` 或 `keys()`，因为弱引用随时可能被回收。
- **只存对象**：基本类型不行，比如 `weakMap.set(42, "nope")` 会报错。

### 3.6 最佳实践

- **缓存计算结果**：用 `WeakMap` 存计算结果，当键对象没用时自动清理。
- **私有数据**：用 `WeakMap` 模拟类的私有属性。

```javascript
const privateData = new WeakMap();
class Person {
  constructor(name) {
    privateData.set(this, { name });
  }
  getName() {
    return privateData.get(this).name;
  }
}
```

---

## 4. 总结与幽默反思

`Set` 是去重小能手，`Map` 是键值自由派，`WeakSet` 和 `WeakMap` 则是内存管理的小透明。这四兄弟各有脾气，但掌握它们后，你的代码会更优雅、更高效。

写这篇文章时，我不禁感慨：JavaScript 的集合类型就像生活中的朋友——有的靠谱（`Set`）、有的多才多艺（`Map`）、有的低调但关键时刻救场（`WeakMap`）。至于我嘛，可能是个 `WeakSet`，存在感不高，但偶尔能帮你清理点垃圾 😂。

希望这篇博客对你有帮助！有什么问题或想法，欢迎留言，咱们一起探讨 🚀。

---