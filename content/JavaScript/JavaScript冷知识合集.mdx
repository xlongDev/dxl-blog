---
title: "JavaScript 冷知识合集：这些特性你都知道吗？"
date: "2023-04-27"
description: "深入挖掘 JavaScript 的冷门特性与隐藏机制，带你走进 JS 的奇妙世界，从原理到实践一个不少。"
keywords: "JavaScript, 冷知识, 前端开发, JS 特性, 原理剖析, 最佳实践"
author: "晓龙"
image: "/images/hero/js-tricks.jpg"
tags: ["JavaScript", "前端开发", "编程技巧"]
category: "JavaScript"
---

JavaScript（以下简称 JS）是个神奇的语言，像个老朋友一样陪伴着我们写前端、搞后端，甚至还能跑在物联网设备上。它表面上平易近人，但骨子里藏着不少“怪脾气”和冷门特性。别看这些知识点冷门，它们有时候能让你代码更优雅，有时候能救你于“调试地狱”之中。今天，我就带你走进 JS 的“冷知识博物馆”，从原理到实践，配上例子和最佳建议，保证你看完能多吹几分钟牛皮！🐂

## 1. `0.1 + 0.2 !== 0.3` 的浮点数阴谋

你有没有写过 `console.log(0.1 + 0.2 === 0.3)`，然后一脸懵逼地看着结果是 `false`？别怀疑人生，这是 JS（其实是 IEEE 754 标准）的浮点数精度问题。

### 原理剖析
JS 用 64 位双精度浮点数表示所有数字。小数在二进制中往往是无限循环的，比如 `0.1` 在二进制里是 `0.0001100110011...`，而计算机只能存有限位数，尾巴就被截断了。加法时，两个“截断怪”相加，结果自然就不精确了，最终 `0.1 + 0.2` 得到的是 `0.30000000000000004`。

### 举个栗子 🌰
```javascript
console.log(0.1 + 0.2); // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3); // false
```

### 最佳实践
- **货币计算别用浮点数**：直接放大成整数操作，比如 `100 * 0.1 + 100 * 0.2`，然后再除回来。
- **用库**：像 `decimal.js` 或 `big.js`，专治浮点精度头疼。
- **toFixed 救急**：`Number((0.1 + 0.2).toFixed(1)) === 0.3` 是 `true`，但小心，它返回的是字符串，得转一下。

**类比**：这就像用尺子量布料，尺子刻度不够细，量出来的总有点偏差。别慌，换把好尺子（库）就行！

## 2. `null` 是对象？别逗我了！

敲 `typeof null`，结果是 `"object"`，这可能是 JS 历史上最出名的“乌龙事件”。

### 原理剖析
在 JS 诞生之初，值是用低位标记类型，`000` 表示对象，而 `null` 本该是个空指针，结果被误打成了对象类型。后来为了兼容性，这 bug 就留下来了。可以说，`null` 是披着对象皮的“假面骑士”。

### 举个栗子 🌰
```javascript
console.log(typeof null); // "object"
console.log(null instanceof Object); // false
```

### 最佳实践
- 判断 `null` 用 `===`，别指望 `typeof`。
- 想知道是不是真对象？用 `instanceof` 或 `Object.prototype.toString.call()`。

**小幽默**：`null` 就像个冒充贵族的平民，身份证上写着“对象”，但祖上查不出三代。

## 3. `[] == ![]` 居然是 `true`？

这题能把人绕晕：空数组等于它自己的取反？听起来像哲学问题。

### 原理剖析
JS 的 `==` 是“宽松相等”，会触发类型转换：
1. `![]`：数组转布尔，空数组是 `true`，取反变 `false`。
2. `[] == false`：右侧是布尔值，左侧数组转原始值，`[]` 调用 `toString()` 变 `""`。
3. `"" == false`：空字符串转布尔也是 `false`，于是 `true`。

### 举个栗子 🌰
```javascript
console.log([] == ![]); // true
console.log([1] == ![1]); // false，因为 [1] 是 true，取反是 false，但 [1] != false
```

### 最佳实践
- 永远用 `===`，除非你故意想玩这种“脑筋急转弯”。
- 类型转换是个坑，写代码时多注释一下逻辑。

**类比**：这就像把苹果和“不是苹果”放在天平上称，结果天平还平衡了，JS 的魔法就是这么玄乎。

## 4. `NaN` 不等于自己

`NaN === NaN` 是 `false`，这可能是 JS 最反直觉的特性之一。

### 原理剖析
`NaN` 表示“不是数字”，但它不是一个具体值，而是一类“无效计算”的标志。根据 IEEE 754 标准，`NaN` 不与任何值相等，包括它自己。

### 举个栗子 🌰
```javascript
console.log(NaN === NaN); // false
console.log(0 / 0 === NaN); // false
```

### 最佳实践
- 用 `isNaN()` 检查，但它不完美（比如 `isNaN("abc")` 也返回 `true`）。
- ES6 的 `Number.isNaN()` 更严格，推荐使用。
```javascript
console.log(Number.isNaN(NaN)); // true
console.log(Number.isNaN("abc")); // false
```

**小幽默**：`NaN` 就像个哲学家，永远在问“我是谁”，但从不承认自己是自己。

## 5. `this` 的千面人生

`this` 是 JS 的“变色龙”，在不同场景下指向完全不同。

### 原理剖析
`this` 的值取决于函数的调用方式：
- 全局调用：指向 `window`（浏览器）或 `global`（Node）。
- 对象方法：指向调用它的对象。
- `call/apply/bind`：手动指定。
- 箭头函数：锁定定义时的外层作用域。

### 举个栗子 🌰
```javascript
const obj = {
  name: "晓龙",
  say: function() { console.log(this.name); },
  sayArrow: () => { console.log(this.name); }
};
obj.say(); // "晓龙"
obj.sayArrow(); // undefined（箭头函数的 this 指向全局）
const fn = obj.say;
fn(); // undefined（丢失上下文）
```

### 最佳实践
- 不确定 `this` 时，打印出来看看，别猜！
- 箭头函数适合回调，但别用在对象方法上。
- 用 `bind` 锁死 `this`，避免意外漂移。

**类比**：`this` 像个跟屁虫，谁叫它它就跟谁，但箭头函数是个“死心眼”，只认定义时的主人。

## 6. `Array.prototype.sort()` 的“字母排序癖”

默认的 `sort()` 不是按数值大小排序，而是按字符串顺序。

### 原理剖析
`sort()` 会把数组元素转为字符串，然后按 Unicode 码点排序。数字 `10` 变成 `"10"`，比 `"2"` 小，因为 `"1"` 开头比 `"2"` 小。

### 举个栗子 🌰
```javascript
const arr = [10, 2, 5, 1];
arr.sort();
console.log(arr); // [1, 10, 2, 5]
arr.sort((a, b) => a - b);
console.log(arr); // [1, 2, 5, 10]
```

### 最佳实践
- 数值排序必须传比较函数：`(a, b) => a - b`。
- 复杂对象排序可以用类似逻辑，比如按年龄排序：
```javascript
const people = [{ age: 25 }, { age: 18 }];
people.sort((a, b) => a.age - b.age);
```

**小幽默**：默认 `sort()` 就像个语文老师，看到数字也非要按拼音排。

## 7. `for...in` 和 `for...of` 的爱恨情仇

这两个循环长得像，但性格完全不同。

### 原理剖析
- `for...in`：遍历对象的**可枚举属性**，包括继承来的，适合对象，不适合数组。
- `for...of`：遍历**可迭代对象**的值，比如数组、字符串、Map，干净利落。

### 举个栗子 🌰
```javascript
const arr = [1, 2, 3];
arr.extra = "oops";
for (let key in arr) console.log(key); // "0", "1", "2", "extra"
for (let val of arr) console.log(val); // 1, 2, 3
```

### 最佳实践
- 数组用 `for...of` 或 `forEach`。
- 对象用 `for...in` 或 `Object.keys()`。

**类比**：`for...in` 像个八卦记者，连家底都翻出来；`for...of` 是直男，只关心眼前的东西。

## 8. `setTimeout` 的“延时谎言”

`setTimeout(fn, 1000)` 不保证正好 1 秒执行。

### 原理剖析
JS 是单线程的，`setTimeout` 把任务扔进事件队列，等主线程空闲才会执行。如果线程被阻塞，延时就变长。

### 举个栗子 🌰
```javascript
console.log("start");
setTimeout(() => console.log("timeout"), 0);
while (Date.now() < Date.now() + 1000) {}
console.log("end");
// 输出顺序：start -> end -> timeout
```

### 最佳实践
- 别指望精确计时，用 `requestAnimationFrame` 做动画更靠谱。
- 调试时加日志，确认执行顺序。

**小幽默**：`setTimeout` 像个不靠谱的朋友，说好 5 分钟到，结果半小时后才出现。

## 结语

JS 的冷知识就像一座宝藏，越挖越有趣。这些特性有的让人抓狂，有的能让你拍案叫绝，但理解它们背后的原理，能让我们写出更稳、更优雅的代码。希望这篇合集能给你带来启发，下次面试或者 debug 时，不妨把这些“冷门武器”掏出来，惊艳一把！💪

你还知道哪些 JS 的冷知识？欢迎留言，咱们一起挖宝！👇
---