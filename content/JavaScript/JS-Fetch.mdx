---
title: "JavaScript Fetch API 全面解析"
date: "2022-01-01"
description: "详解 JavaScript 的 Fetch API，包括基础用法、配置选项、错误处理、高级技巧以及与传统 XMLHttpRequest 的对比，帮助你更高效地进行网络请求。"
keywords: "JavaScript, Fetch API, HTTP 请求, 前端开发, 异步编程, 网络编程"
author: "晓龙"
image: "/images/hero/fetch-api.jpg"
tags: ["JavaScript", "Fetch API", "HTTP", "前端开发", "异步编程"]
category: "JavaScript"
---

想象一下，当你在餐厅点餐时 🍽️，服务员（Fetch API）接收你的点餐单（请求），然后去厨房取餐（服务器），最后把美味的菜品（响应数据）端到你的餐桌上。这就是 Fetch API 在网络请求中扮演的角色！作为现代 JavaScript 中的"网络服务员"，它基于 Promise 设计，让异步操作变得优雅自然，就像一位经验丰富的服务员总能准确、高效地完成你的需求。本篇博客将带你深入了解这位"网络服务员"的各种技能，包括基本用法 📝、配置选项 ⚙️、错误处理 🚨、跨域请求 🌐，以及在实际项目中的应用案例。无论你是刚入门的学徒，还是经验丰富的主厨，都能在这里找到适合你的"菜品"！

## 1. Fetch API 简介 🌟

就像餐厅从传统的纸质点单升级到现代化的平板点餐系统一样，Web 开发也在 2015 年迎来了全新的 Fetch API。相比传统的 `XMLHttpRequest`（就像老式的纸质点单），Fetch 就像一个智能点餐系统，通过 Promise 机制让整个流程更加流畅和可控。

**优点：** 🎯

- **基于 Promise：** 就像智能点餐系统的订单跟踪，让你随时知道请求的状态。
- **语法简洁：** 像使用智能手机一样直观，告别繁琐的配置。
- **灵活性高：** 就像定制餐品一样，可以灵活配置各种 HTTP 方法、请求头和请求体。
- **支持流式数据：** 能够像视频直播一样，逐步处理大型数据。

**缺点：** ⚠️

- **进度监控需要特殊处理：** 就像某些外卖平台不能实时追踪骑手位置一样，Fetch 原生不支持进度监控（但我们后面会介绍如何解决这个问题）。
- **错误处理需要额外注意：** 类似于餐厅服务生不会因为厨房没有食材就直接拒绝你的订单，Fetch 对 HTTP 错误状态也不会自动 reject，需要我们手动检查。

## 2. 基本用法 🚀

就像在餐厅点一杯咖啡一样简单，Fetch API 的基本使用只需要调用全局的 `fetch` 方法，并传入 URL 即可。让我们从最简单的"点单"开始！

### 示例：GET 请求

```js
fetch("https://api.example.com/data")
  .then((response) => {
    // 判断响应是否成功
    if (!response.ok) {
      throw new Error(`网络响应失败，状态码: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => {
    console.log("数据获取成功：", data);
  })
  .catch((error) => {
    console.error("请求出现错误：", error);
  });
```

在上面的代码中，我们发起了一个 GET 请求，使用 `.then()` 处理响应，并利用 `.catch()` 捕获网络错误或状态异常。

### 示例：POST 请求

对于需要发送数据的请求，可以传入第二个配置参数。

```js
fetch("https://api.example.com/users", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    name: "张三",
    age: 25,
  }),
})
  .then((response) => {
    if (!response.ok) {
      throw new Error(`网络响应失败，状态码: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => {
    console.log("用户创建成功：", data);
  })
  .catch((error) => {
    console.error("请求出现错误：", error);
  });
```

此示例中，我们构造了一个 POST 请求，发送 JSON 格式的数据，并设置了相应的请求头。

## 3. Fetch 的配置选项 ⚙️

就像餐厅菜单上的各种定制选项一样，Fetch API 也提供了丰富的配置选项来满足不同的需求。让我们来看看这些"调味料"：

- **method 📝:** 请求方法，就像点餐时说明是"堂食"还是"打包"，可以是 `GET`, `POST`, `PUT`, `DELETE` 等。
- **headers 📋:** 请求头对象，相当于订单的特殊要求，用来设置内容类型、授权信息等。
- **body 📦:** 请求体，就像具体的点餐内容，仅在 `POST`、`PUT` 等方法中使用，可以是多种格式。
- **credentials 🔑:** 用于指定是否发送 Cookie，就像会员卡信息，可以是 `omit`、`same-origin`、`include`。
- **cache 💾:** 缓存模式，就像餐厅的预制菜品，可以是 `default`、`no-store`、`reload` 等。
- **redirect 🔄:** 重定向模式，就像餐位的调整，可以是 `follow`、`error`、`manual`。
- **mode 🌐:** 请求模式，就像就餐模式的选择，可以是 `cors`、`no-cors` 或 `same-origin`。

### 示例：自定义请求配置

```js
fetch("https://api.example.com/secure-data", {
  method: "GET",
  headers: {
    Authorization: "Bearer your-token-here",
    Accept: "application/json",
  },
  credentials: "include", // 包含跨域请求时的 cookie
  cache: "no-cache",
  mode: "cors",
})
  .then((response) => {
    if (!response.ok) {
      throw new Error(`网络响应失败，状态码: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => {
    console.log("安全数据：", data);
  })
  .catch((error) => {
    console.error("请求出现错误：", error);
  });
```

在这个例子中，我们演示了如何发送带有授权头和 cookie 的请求，同时禁用了缓存并指定了跨域模式。

## 4. 响应处理 🎯

Fetch 返回的是一个 `Response` 对象，就像餐厅服务员端来的餐盘，里面可能装着各种类型的"美食"（数据）。让我们看看如何"品尝"这些数据：

- **response.json() 📊:** 将响应体解析为 JSON 对象，就像把一份精美的套餐拆分成各个部分。
- **response.text() 📝:** 将响应体解析为纯文本，适合处理简单的文本数据，就像阅读菜品说明。
- **response.blob() 📦:** 将响应体解析为 Blob 对象，常用于文件下载，就像打包带走的美食。
- **response.arrayBuffer() 🔢:** 将响应体解析为 ArrayBuffer，用于处理二进制数据，就像厨师处理原材料。
- **response.formData() 📋:** 将响应体解析为 FormData 对象，就像填写餐厅的意见反馈表。

### 示例：处理不同类型的响应数据

```js
// 处理 JSON 数据
fetch("https://api.example.com/data.json")
  .then((response) => response.json())
  .then((data) => {
    console.log("JSON 数据：", data);
  });

// 处理文本数据
fetch("https://api.example.com/readme.txt")
  .then((response) => response.text())
  .then((text) => {
    console.log("文本数据：", text);
  });

// 处理二进制数据（如图片或文件）
fetch("https://api.example.com/image.png")
  .then((response) => response.blob())
  .then((blob) => {
    const url = URL.createObjectURL(blob);
    const img = document.createElement("img");
    img.src = url;
    document.body.appendChild(img);
  });
```

## 5. 错误处理

Fetch 只会在网络故障或者请求被阻止时 reject promise，对于 HTTP 状态码错误（如 404、500 等）不会自动 reject。因此，建议手动判断 `response.ok` 属性来捕捉这些错误。

### 示例：统一错误处理

```js
fetch("https://api.example.com/data")
  .then((response) => {
    if (!response.ok) {
      // 构造自定义错误对象
      const error = new Error(`HTTP 错误: ${response.status}`);
      error.status = response.status;
      throw error;
    }
    return response.json();
  })
  .then((data) => {
    console.log("获取数据成功：", data);
  })
  .catch((error) => {
    // 统一处理网络和 HTTP 错误
    console.error("请求失败：", error);
  });
```

这种处理方式可以让你在 catch 块中统一捕获所有错误，便于日志记录和用户提示。

## 6. 高级用法

### 6.1. 使用 Async/Await 🎯

就像餐厅服务员按顺序处理多个订单一样，async/await 让我们能够以更直观的方式处理多个异步请求。不再需要复杂的 Promise 链式调用，代码更加清晰易读。

```js
async function fetchUserData() {
  try {
    const response = await fetch("https://api.example.com/user/1");
    if (!response.ok) {
      throw new Error(`HTTP 错误: ${response.status}`);
    }
    const userData = await response.json();
    console.log("用户数据：", userData);

    // 基于用户数据获取更多信息
    const ordersResponse = await fetch(
      `https://api.example.com/orders/${userData.id}`
    );
    if (!ordersResponse.ok) {
      throw new Error(`HTTP 错误: ${ordersResponse.status}`);
    }
    const orders = await ordersResponse.json();
    console.log("订单数据：", orders);
  } catch (error) {
    console.error("数据获取失败：", error);
  }
}

// 调用函数
fetchUserData();
```

### 6.2. 取消请求 🚫

有时候，就像顾客改变主意取消订单一样，我们可能需要取消正在进行的网络请求。Fetch API 提供了 `AbortController` 来实现这个功能：

```js
const controller = new AbortController();
const signal = controller.signal;

fetch("https://api.example.com/large-data", { signal })
  .then((response) => response.json())
  .then((data) => console.log("数据：", data))
  .catch((err) => {
    if (err.name === "AbortError") {
      console.log("请求已取消 🚫");
    } else {
      console.error("其他错误：", err);
    }
  });

// 3秒后取消请求
setTimeout(() => {
  controller.abort();
  console.log("请求已手动取消！");
}, 3000);
```

### 6.3. 上传进度监控 📊

虽然 Fetch API 本身不直接支持进度监控，但我们可以结合 `ReadableStream` 来实现这个功能：

```js
async function uploadFileWithProgress(file) {
  const contentLength = file.size;
  let uploadedLength = 0;

  const stream = new ReadableStream({
    start(controller) {
      const reader = file.stream().getReader();
      return pump();

      function pump() {
        return reader.read().then(({ done, value }) => {
          if (done) {
            controller.close();
            return;
          }
          uploadedLength += value.length;
          const progress = (uploadedLength / contentLength) * 100;
          console.log(`上传进度: ${progress.toFixed(2)}%`);
          controller.enqueue(value);
          return pump();
        });
      }
    },
  });

  const response = await fetch("https://api.example.com/upload", {
    method: "POST",
    body: stream,
  });

  if (!response.ok) {
    throw new Error(`上传失败: ${response.status}`);
  }

  return await response.json();
}
```

### 6.4. 流式数据处理 🌊

就像餐厅的实时点餐系统可以即时显示订单状态一样，Fetch API 也支持流式数据处理，特别适合处理大型数据或实时更新：

```js
fetch("https://api.example.com/stream")
  .then((response) => {
    const reader = response.body.getReader();
    return new ReadableStream({
      start(controller) {
        return pump();
        function pump() {
          return reader.read().then(({ done, value }) => {
            if (done) {
              controller.close();
              return;
            }
            controller.enqueue(value);
            return pump();
          });
        }
      },
    });
  })
  .then((stream) => new Response(stream))
  .then((response) => response.json())
  .then((data) => console.log("流式数据：", data));
```

## 7. 最佳实践与注意事项 💡

在使用 Fetch API 时，有一些重要的最佳实践需要注意：

1. **总是检查响应状态** 🔍

   - 不要忘记检查 `response.ok`
   - 对不同的状态码进行适当处理

2. **合理设置超时** ⏰

   ```js
   const timeout = 5000;
   const controller = new AbortController();
   const timeoutId = setTimeout(() => controller.abort(), timeout);

   try {
     const response = await fetch(url, { signal: controller.signal });
     clearTimeout(timeoutId);
     const data = await response.json();
     // 处理数据
   } catch (error) {
     if (error.name === "AbortError") {
       console.log("请求超时");
     }
   }
   ```

3. **错误重试机制** 🔄

   ```js
   async function fetchWithRetry(url, options = {}, retries = 3) {
     try {
       return await fetch(url, options);
     } catch (error) {
       if (retries > 0) {
         console.log(`重试剩余次数: ${retries}`);
         return await fetchWithRetry(url, options, retries - 1);
       }
       throw error;
     }
   }
   ```

4. **缓存策略** 📦

   - 合理使用 `cache` 选项
   - 考虑实现本地缓存机制

5. **安全性考虑** 🔒
   - 使用 HTTPS
   - 谨慎处理敏感数据
   - 注意 CORS 策略

```javascript
try {
  const response = await fetch("https://api.example.com/data");
  if (!response.ok) {
    throw new Error(`HTTP 错误: ${response.status}`);
  }
  const data = await response.json();
  console.log("获取数据成功：", data);
} catch (error) {
  console.error("请求失败：", error);
}
```

fetchData();

````

### 6.2. 超时控制

Fetch 本身没有内置超时机制，可以通过 `Promise.race` 来实现。

```js
function fetchWithTimeout(url, options = {}, timeout = 5000) {
  return Promise.race([
    fetch(url, options),
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error("请求超时")), timeout)
    ),
  ]);
}

fetchWithTimeout("https://api.example.com/data")
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP 错误: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => {
    console.log("数据获取成功：", data);
  })
  .catch((error) => {
    console.error("请求出现错误：", error);
  });
````

### 6.3. 并行请求

使用 `Promise.all` 可以同时发起多个请求，并在全部完成后统一处理返回的数据。

```js
Promise.all([
  fetch("https://api.example.com/data1").then((res) => res.json()),
  fetch("https://api.example.com/data2").then((res) => res.json()),
])
  .then(([data1, data2]) => {
    console.log("数据1：", data1);
    console.log("数据2：", data2);
  })
  .catch((error) => {
    console.error("请求失败：", error);
  });
```

## 7. Fetch 与 XMLHttpRequest 的对比

虽然 Fetch API 有很多优点，但在某些场景下 `XMLHttpRequest` 依然有其适用之处：

- **进度监控：** `XMLHttpRequest` 可以监控上传和下载进度，而 Fetch 需要借助额外的 API（如 Streams）实现。
- **兼容性：** 在一些较老的浏览器中，`XMLHttpRequest` 可能仍然是唯一可用的选择，不过现在大部分现代浏览器都已支持 Fetch。
- **响应处理：** Fetch 默认不会 reject HTTP 错误，需要开发者手动判断，而 `XMLHttpRequest` 则可以通过状态码直接得知请求是否成功。

总体来说，对于大多数前端开发场景，Fetch 提供了更为简洁和现代的解决方案。

## 8. 实际案例：调用第三方 API

假设我们需要调用 GitHub 的用户 API 来获取用户信息，可以使用 Fetch API 如下实现：

```js
async function getGitHubUser(username) {
  try {
    const response = await fetch(`https://api.github.com/users/${username}`, {
      headers: {
        Accept: "application/vnd.github.v3+json",
      },
    });
    if (!response.ok) {
      throw new Error(`GitHub 用户请求失败，状态码: ${response.status}`);
    }
    const userData = await response.json();
    console.log("GitHub 用户数据：", userData);
  } catch (error) {
    console.error("请求 GitHub 用户数据失败：", error);
  }
}

getGitHubUser("octocat");
```

通过这个实际案例，你可以看到 Fetch API 在调用第三方 API 时的便捷性和灵活性。

## 9. 总结

在这篇博客中，我们详细介绍了 JavaScript Fetch API 的基本用法、常用配置选项、响应和错误处理以及一些高级用法，如 async/await、超时控制和并行请求。Fetch API 为现代前端开发提供了一种简洁、直观的网络请求方式，是替代 `XMLHttpRequest` 的优秀选择。

掌握 Fetch API 后，你可以更高效地进行网络编程，并应对各种实际开发场景。如果你有更多的问题或经验，欢迎在评论区留言交流！

Happy Coding!
