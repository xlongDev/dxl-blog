---
title: "深入解析 JavaScript 的迭代器与生成器"
date: "2022-08-07"
description: "从原理到实践，带你彻底搞懂 JavaScript 的迭代器和生成器，附带实用案例和最佳实践。"
keywords: "JavaScript, 迭代器, 生成器, Iterator, Generator, ES6, 前端开发"
author: "晓龙"
image: "/images/hero/iterators-generators.jpg"
tags: ["JavaScript", "ES6", "前端开发"]
category: "JavaScript"
---

如果你在 JavaScript 的世界里摸爬滚打了一段时间，可能会觉得迭代器（Iterator）和生成器（Generator）有点像“编程界的魔法师”：看起来高深莫测，用好了却能让代码优雅得像一场华丽的表演。今天，我们就来掀开它们的神秘面纱，从原理到实践，带你彻底搞懂这两个 ES6 的明星特性。不仅有硬核的理论，还有接地气的例子和最佳实践，保证你看完既能“哇塞”又能“哦原来如此”！🚀

## 什么是迭代器？从“可迭代”说起

先问一个问题：你有没有想过，为什么可以用 `for...of` 循环遍历数组、字符串甚至 Map，却不能直接遍历普通对象？答案藏在“可迭代协议”（Iterable Protocol）里。

在 JavaScript 中，一个对象要想变得“可迭代”，就得实现 `@@iterator` 方法（也就是 `Symbol.iterator`）。这个方法返回一个迭代器对象，而迭代器对象需要提供一个 `next()` 方法，每次调用时返回 `{ value, done }` —— `value` 是当前值，`done` 表示是否迭代完成。

听起来有点绕？别急，我们用一个类比：想象你在吃一袋薯片（数组），`Symbol.iterator` 就像薯片包装上的拉链，拉开后你拿到一个“薯片提取器”（迭代器），每次调用 `next()` 就拿出一片薯片，直到袋子空了（`done: true`）。

### 动手写一个简单的迭代器

来看个例子，假设我们要自定义一个从 1 数到 5 的迭代器：

```javascript
const myIterator = {
  current: 1,
  max: 5,
  next() {
    if (this.current <= this.max) {
      return { value: this.current++, done: false };
    }
    return { done: true };
  }
};

let result = myIterator.next();
while (!result.done) {
  console.log(result.value); // 1, 2, 3, 4, 5
  result = myIterator.next();
}
```

简单吧？但这还不够优雅，因为没法直接用 `for...of`。我们得让它遵守“可迭代协议”：

```javascript
const countable = {
  [Symbol.iterator]() {
    let current = 1;
    const max = 5;
    return {
      next() {
        if (current <= max) {
          return { value: current++, done: false };
        }
        return { done: true };
      }
    };
  }
};

for (const num of countable) {
  console.log(num); // 1, 2, 3, 4, 5
}
```

现在，`countable` 变成了一个“可迭代对象”，可以用 `for...of`、扩展运算符（`...`）甚至解构赋值随便玩了。是不是有点酷？😎

### 内置迭代器的秘密

其实，数组、字符串、Set、Map 这些内置类型都自带 `Symbol.iterator`。比如：

```javascript
const arr = [1, 2, 3];
const iterator = arr[Symbol.iterator]();
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

这就像是 JavaScript 给你开了一扇“迭代之门”，让你能轻松遍历数据结构。不过，普通对象没有默认实现这个协议，想让它可迭代？那得自己动手改造了（后面会讲到）。

## 生成器：迭代器的“懒人版”升级

如果说迭代器是个勤劳的手工匠人，那生成器（Generator）就是个聪明又有点懒的魔法师。它不仅能生成迭代器，还能让你用更少的代码控制迭代过程。生成器是通过 `function*` 语法定义的，返回一个 Generator 对象，这个对象既是迭代器又是可迭代对象（双重身份，够炫吧？）。

### 初探生成器

来看个简单的生成器：

```javascript
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numberGenerator();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
```

这里的 `yield` 就像是“暂停按钮”，每次调用 `next()`，函数执行到 `yield` 就停下来，返回当前值，等你再次调用时再继续。比起手动写迭代器，这种写法简直是“懒人福音”。

### 生成器的“暂停与恢复”魔法

生成器的真正强大之处在于它的“暂停与恢复”能力。来看个更有趣的例子：

```javascript
function* cookingRecipe() {
  console.log("Step 1: 准备食材");
  yield "鸡蛋";
  console.log("Step 2: 加热锅子");
  yield "煎蛋";
  console.log("Step 3: 装盘");
  yield "享用";
}

const recipe = cookingRecipe();
console.log(recipe.next().value); // "鸡蛋"，打印 "Step 1: 准备食材"
console.log(recipe.next().value); // "煎蛋"，打印 "Step 2: 加热锅子"
console.log(recipe.next().value); // "享用"，打印 "Step 3: 装盘"
```

这就像你在厨房做饭，每一步都可以停下来喝口水，等你喊“继续”时再进行下一步。生成器把控制权交给了调用者，这种“协作式调度”在异步编程中尤其有用（后面会讲到）。

### 双向通信：yield 的秘密武器

生成器还有个隐藏技能：`next()` 可以传参，参数会作为上一个 `yield` 的返回值。看这个例子：

```javascript
function* askQuestions() {
  const name = yield "你叫什么名字？";
  const age = yield `你好 ${name}，你几岁了？`;
  return `哇，${name} 你 ${age} 岁了！`;
}

const q = askQuestions();
console.log(q.next().value); // "你叫什么名字？"
console.log(q.next("晓龙").value); // "你好 晓龙，你几岁了？"
console.log(q.next(25).value); // "哇，晓龙 你 25 岁了！"
```

这就像一个问答游戏，你回答一个问题，生成器根据你的答案继续“聊下去”。这种双向通信让生成器在处理动态数据时特别灵活。

## 深入原理：迭代器与生成器的底层逻辑

### 迭代器的本质

迭代器本质上是一个“状态机”。每次调用 `next()`，它根据内部状态返回当前值并更新状态，直到结束。内置迭代器（比如数组的）是由 JavaScript 引擎用 C++ 实现的，效率高得飞起。而我们手写的迭代器则是用 JS 模拟这种行为。

### 生成器的工作机制

生成器背后其实是 JavaScript 的“协程”（Coroutine）思想。普通函数是一口气跑完的“独裁者”，而生成器是“民主派”，它通过 `yield` 把执行权交给调用者。引擎会在每次 `yield` 时保存函数的调用栈和上下文，等 `next()` 被调用时恢复执行。这也是为什么生成器能“暂停”的秘密。

用伪代码表示生成器的执行过程大概是这样的：

```javascript
// 伪代码
function* generator() {
  yield 1;
  yield 2;
}
const gen = generator();
// 内部状态机：
/*
  状态 0: 初始 -> yield 1 -> 暂停
  状态 1: 恢复 -> yield 2 -> 暂停
  状态 2: 恢复 -> 结束
*/
```

这种机制让生成器在内存占用上非常高效，因为它不像数组那样一次性生成所有值，而是“按需生产”。

## 实用场景与最佳实践

### 1. 无限序列的优雅实现

想生成一个无限的斐波那契数列？用生成器简直不要太简单：

```javascript
function* fibonacci() {
  let [prev, curr] = [0, 1];
  while (true) {
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

const fib = fibonacci();
console.log(fib.next().value); // 1
console.log(fib.next().value); // 1
console.log(fib.next().value); // 2
console.log(fib.next().value); // 3
console.log(fib.next().value); // 5
```

这种“懒加载”方式特别适合处理大数据或流式数据，因为它不会一次性占用大量内存。

**最佳实践**：在无限序列中，记得加个退出条件（比如最大值），不然调用者可能会陷入“无穷无尽的循环地狱”。

### 2. 异步操作的“救世主”

生成器和 Promise 搭配，能写出同步风格的异步代码（在 async/await 普及前，这可是神器）：

```javascript
function* fetchData() {
  const user = yield fetch("https://api.example.com/user").then(res => res.json());
  const posts = yield fetch(`https://api.example.com/posts/${user.id}`).then(res => res.json());
  return posts;
}

function run(gen) {
  const iterator = gen();
  function nextStep(result) {
    if (result.done) return result.value;
    return result.value.then(data => nextStep(iterator.next(data)));
  }
  nextStep(iterator.next());
}

run(fetchData);
```

虽然现在有 async/await，但理解这种模式能帮你更深刻地掌握异步控制流。

**最佳实践**：如果项目允许，直接用 async/await，毕竟它更简洁。但在需要精细控制异步逻辑时，生成器依然是备选方案。

### 3. 自定义可迭代对象

想让普通对象支持 `for...of`？用生成器改造一下：

```javascript
const myObject = {
  a: 1,
  b: 2,
  c: 3,
  *[Symbol.iterator]() {
    for (const key in this) {
      yield [key, this[key]];
    }
  }
};

for (const [key, value] of myObject) {
  console.log(`${key}: ${value}`); // a: 1, b: 2, c: 3
}
```

**最佳实践**：在生成器中处理复杂逻辑时，记得用 try-catch 捕获异常，避免迭代意外中断。

## 一些幽默的小彩蛋

- **迭代器 vs 生成器**：迭代器像个老实的手工匠人，一步步干活；生成器则是“懒癌晚期”，非得你催一下才动一下。
- **yield 的哲学**：它就像程序员的午休时间——暂停一下，喝杯咖啡，回来再战！
- **无限生成器**：小心别让它跑过头，不然你的代码会变成“永动机”，老板看了都想给你加薪（或者炒鱿鱼）。

## 总结

迭代器和生成器是 JavaScript 中强大而灵活的工具。迭代器让你能自定义遍历逻辑，生成器则在懒加载、异步控制和动态数据处理中大放异彩。掌握它们不仅能让代码更优雅，还能让你在面试时多一份“硬核谈资”。

希望这篇文章能让你对迭代器和生成器有个从“懵圈”到“通透”的转变。如果你有更多奇思妙想或实践经验，欢迎在评论区分享！毕竟，编程的乐趣就在于探索和创造嘛。✨

---