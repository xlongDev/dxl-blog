---

title: "聊聊 new 操作符的实现原理"
date: "2022-12-18"
description: "从 JavaScript 的 new 操作符入手，深入剖析其实现原理，结合源码解析和实例，带你理解背后的机制与细节。"
keywords: "JavaScript, new 操作符, 构造函数, 原型链, 对象创建, 源码解析"
author: "晓龙"
image: "/images/hero/new-operator.jpg"
tags: ["JavaScript", "前端开发", "源码解析"]
category: "JavaScript"

---

JavaScript 中的 `new` 操作符是我们日常开发中常用的工具之一。无论是创建对象实例，还是实现类的功能，它都扮演着核心角色。然而，这个看似简单的关键字背后，却隐藏着不少有趣的机制和细节。今天，我们就来聊聊 `new` 操作符的实现原理，从它的行为逻辑，到源码层面的模拟，再到一些实际案例，一步步揭开它的神秘面纱。

## 什么是 `new` 操作符？

在 JavaScript 中，`new` 是一个关键字，通常与构造函数（constructor function）一起使用，用于创建对象实例。比如下面这个简单的例子：

```javascript
function Person(name) {
  this.name = name;
}

const xiaolong = new Person("晓龙");
console.log(xiaolong.name); // "晓龙"
```

通过 `new Person("晓龙")`，我们得到了一个新对象 `xiaolong`，它的 `name` 属性被赋值为 `"晓龙"`。这看起来很简单，但 `new` 在背后究竟做了什么？它的实现原理又是怎样的呢？

### `new` 的核心行为

根据 ECMAScript 规范（具体来说是 ECMA-262），`new` 操作符在执行时会触发以下几个步骤：

1. **创建一个新对象**：生成一个空的对象 `{}`。
2. **设置原型链**：将新对象的 `__proto__` 属性指向构造函数的 `prototype`。
3. **执行构造函数**：以新对象作为 `this` 的上下文，调用构造函数，并传入参数。
4. **返回对象**：如果构造函数没有显式返回一个对象，则返回新创建的对象；否则，返回构造函数返回的对象。

这四个步骤听起来很抽象，我们不妨用代码来模拟一下 `new` 的行为。

## 模拟 `new` 的实现

为了更直观地理解 `new`，我们可以自己动手写一个函数来模拟它的行为。假设我们叫它 `myNew`：

```javascript
function myNew(constructor, ...args) {
  // 1. 创建一个空对象
  const obj = {};

  // 2. 将新对象的 __proto__ 指向构造函数的 prototype
  Object.setPrototypeOf(obj, constructor.prototype);

  // 3. 以新对象为 this，执行构造函数
  const result = constructor.apply(obj, args);

  // 4. 判断返回值类型，如果是对象则返回它，否则返回新创建的对象
  return result instanceof Object && result !== null ? result : obj;
}
```

让我们用这个 `myNew` 来测试一下，看看它是否能替代 `new`：

```javascript
function Person(name) {
  this.name = name;
}

const xiaolong = myNew(Person, "晓龙");
console.log(xiaolong.name); // "晓龙"
console.log(xiaolong instanceof Person); // true
```

完美！`myNew` 成功创建了一个 `Person` 的实例，`name` 属性被正确赋值，而且原型链也设置正确。这说明我们的模拟已经非常接近 `new` 的实际行为了。

但这只是基础情况，`new` 的实现还有一些细节需要深入探讨。我们接下来逐一拆解这几个步骤，并结合例子看看它们在真实场景中是如何工作的。

## 深入剖析每个步骤

### 1. 创建一个新对象

`new` 的第一步是创建一个空对象。在 V8 引擎（Chrome 和 Node.js 的 JavaScript 引擎）的源码层面，这一步通常是通过内存分配实现的。V8 会调用内部的 `FastNewObject` 函数，快速分配一个对象。这个对象本质上是一个普通的 JavaScript 对象 `{}`，没有任何属性。

在我们的模拟中，我们简单地用 `const obj = {}` 来实现，但在引擎层面，这涉及到内存管理和对象池的优化。普通开发者无需关心这些底层细节，但知道这一点可以帮助我们理解为什么 `new` 的性能通常很高。

### 2. 设置原型链

第二步是将新对象的 `__proto__` 属性指向构造函数的 `prototype`。这其实是 JavaScript 原型链机制的核心所在。通过这一步，新对象继承了构造函数原型上的所有属性和方法。

比如：

```javascript
function Animal(type) {
  this.type = type;
}
Animal.prototype.say = function () {
  console.log(`I am a ${this.type}`);
};

const dog = new Animal("dog");
dog.say(); // "I am a dog"
```

在这里，`dog.__proto__ === Animal.prototype`，所以 `dog` 能访问到 `say` 方法。在我们的 `myNew` 中，这一步通过 `Object.setPrototypeOf(obj, constructor.prototype)` 实现。现代 JavaScript 提供了这个 API，但在老版本中，你可能会看到类似的写法：

```javascript
obj.__proto__ = constructor.prototype;
```

需要注意的是，`__proto__` 是一个非标准的属性，虽然大多数引擎都支持，但更推荐使用 `Object.setPrototypeOf` 或 `Object.create`。

### 3. 执行构造函数

第三步是以新对象作为 `this`，执行构造函数。这一步是 `new` 的“魔法”所在，因为它改变了函数的调用上下文。

在 V8 引擎中，这一步是通过 `Construct` 内部函数完成的。`Construct` 会绑定 `this` 并执行函数体。我们用 `constructor.apply(obj, args)` 模拟了这个过程。

来看一个稍微复杂的例子：

```javascript
function Car(brand, color) {
  this.brand = brand;
  this.color = color;
  this.drive = function () {
    console.log(`Driving a ${this.color} ${this.brand}`);
  };
}

const bmw = new Car("BMW", "black");
bmw.drive(); // "Driving a black BMW"
```

在这里，`this` 被绑定到新对象上，`brand`、`color` 和 `drive` 都被添加到了新对象中。如果没有 `new`，直接调用 `Car("BMW", "black")`，`this` 会指向全局对象（非严格模式下），结果完全不同。

### 4. 返回对象

最后一步是返回结果。`new` 的返回值有一个有趣的规则：如果构造函数显式返回一个对象，则返回这个对象；否则，返回新创建的对象。

来看看这个特性：

```javascript
function Foo(name) {
  this.name = name;
  return { name: "overridden" };
}

const foo = new Foo("original");
console.log(foo.name); // "overridden"
```

这里，构造函数返回了一个新对象 `{ name: "overridden" }`，所以 `new Foo` 的结果是这个对象，而不是原本创建的带有 `name: "original"` 的对象。

再看一个不返回对象的例子：

```javascript
function Bar(name) {
  this.name = name;
  return "not an object";
}

const bar = new Bar("晓龙");
console.log(bar.name); // "晓龙"
```

返回的 `"not an object"` 不是对象类型，所以被忽略，最终返回的是新创建的对象。这在我们的 `myNew` 中通过 `return result instanceof Object && result !== null ? result : obj` 实现。

## 一些有趣的边界情况

`new` 的实现看似简单，但在实际使用中会遇到一些有趣的边界情况。我们通过几个例子来探讨一下。

### 1. 没有 `prototype` 的构造函数

如果构造函数没有 `prototype` 属性，会发生什么？比如箭头函数：

```javascript
const ArrowPerson = (name) => {
  this.name = name; // 报错：this is not defined
};

const p = new ArrowPerson("晓龙"); // TypeError: ArrowPerson is not a constructor
```

箭头函数没有 `prototype` 属性，也无法通过 `new` 调用，因为它们的 `this` 是词法绑定的。这种情况下，引擎会直接抛出异常。

### 2. `new` 与 `class`

现代 JavaScript 中，`class` 语法是对构造函数的封装，但本质上还是通过 `new` 实现的。比如：

```javascript
class Dog {
  constructor(name) {
    this.name = name;
  }
  bark() {
    console.log(`${this.name} says woof!`);
  }
}

const dog = new Dog("旺财");
dog.bark(); // "旺财 says woof!"
```

在底层，`class Dog` 被编译成一个构造函数，`bark` 被添加到 `Dog.prototype` 上，`new` 的行为和普通构造函数一致。

### 3. 原型链的动态修改

`new` 创建对象后，如果修改构造函数的 `prototype`，会影响已有实例吗？

```javascript
function Test() {}
const t1 = new Test();
Test.prototype.say = function () {
  console.log("Hello");
};
t1.say(); // "Hello"
```

答案是会的，因为 `t1.__proto__` 仍然指向 `Test.prototype`，这是一个动态的引用关系。

## 从源码角度再看 `new`

如果你对 V8 引擎的源码感兴趣，可以看看 `new` 的实现。以下是简化的伪代码（基于 V8 的 C++ 实现）：

```cpp
Object* JSFunction::Construct(Arguments args) {
  // 创建新对象
  Object* obj = FastNewObject();

  // 设置原型
  obj->set_prototype(GetPrototype());

  // 执行构造函数
  JSFunction::Call(obj, args);

  // 返回结果（省略返回值检查的细节）
  return obj;
}
```

这只是高度简化的版本，实际代码涉及更多优化，比如内联缓存（inline caching）和快速路径（fast path）。但核心逻辑和我们前面提到的四步是一致的。

## 总结与思考

通过上面的分析，我们可以看到，`new` 操作符虽然简单，却完美地结合了 JavaScript 的对象创建和原型继承机制。它不仅是一个语法糖，更是一个桥梁，连接了构造函数和实例之间的关系。

写到这里，我不禁感慨：JavaScript 的设计真是既灵活又优雅。`new` 的实现看似直白，但通过原型链和动态 `this` 绑定，它为开发者提供了无限可能。无论是面向对象编程，还是函数式编程，`new` 都能找到自己的位置。

希望这篇文章能让你对 `new` 有更深的理解。如果你有更多关于 `new` 的疑问，或者想探讨其他 JavaScript 的实现原理，欢迎留言交流！

--- 